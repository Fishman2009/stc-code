双CPU，普通I/O，3线通信


3线双向零等待IO通讯机制


许多设备需要通过IO通讯交互数据,怎样才做到速度最快,通讯可靠,所用资源又少呢?
下面介绍一个我编写的通讯协议:
它没有1线,2线那样节省IO资源,但是它的通讯速度绝对最快,无需延时,且不用中断,还可以
对等传输.
实际情况下C51编写，实现了50us传输一个字节，折合160Kbps左右，晶振22M。

特点如下:
使用3根普通IO通讯
不使用中断
双方都可以主动发起数据通讯,也都可以被动接收数据,即可以对等传输.
有发送和接收的检查等待机制,发送方知道对方什么时候收了数据,接收方知道发送方什么时
候发了数据.
无需进行数据延时,最大可能地加快了通讯速度.
CPU闲的时候通讯速率可以最快.忙的时候又可以无限等待.保证绝对同步,不会出错.
双方CPU工作速度可以任意,即使是51和P4通讯,也能保证正确无误.

    ask w1    w2    w3    w4    w5    w6    w7    w8            
MCLK ┐┌──┐    ┌──┐    ┌──┐    ┌──┐    ┌───            
     └┘    └──┘    └──┘    └──┘    └──┘ 
                          
SDT ___┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐________
       └─┘└─┘└─┘└─┘└─┘└─┘└─┘└─┘  

SCLK  ┐  ┌──┐    ┌──┐    ┌──┐    ┌──┐    ┌─                 
      └─┘    └──┘    └──┘    └──┘    └──┘
    res  r1    r2    r3    r4    r5    r6    r7    r8                           

1.主机发起通讯申请到从机
主机检测MCLK是否为0,为0的话是对方在申请通讯,退出函数.
主机检测到MCLK=1,表示通讯空闲.
主机将MCLK=0,表示申请通讯. 之后检测SCLK是否为0(是否响应通讯)

2.从机响应通讯,从机在闲时检测MCLK是否为0,发现为0则主机向它发起了通讯申请.
从机将SCLK=0,表示接受申请,之后检测MCLK是否变为1,如果是1则主机已经发出了第一个bit
的数据.  

3.主机发现SCLK=0,知道从机已经开始准备接受数据.
4.主机发送第一个bit到SDA.
5.主机将MCLK=1,表示已经发送第一个bit到SDA.

6.从机发现MCLK=1,知道主机已经发出第一个数据
7.从机收第一个bit的数据.
8.从机将SCLK=1,表示已经收了第一个bit.之后等待MCLK是否变0,如果变0,则主机已经发出
了第二个bit


9.主机发现SCLK=1,知道从机已经开始准备接受第二个数据.
10.主机发送第二个bit到SDA.
11.主机将MCLK=0,表示已经发送第二个bit到SDA.

12.从机发现MCLK=0,知道主机已经发出第二个数据
13.从机收第二个bit的数据.
14.从机将SCLK=0,表示已经收了第二个bit.之后等待MCLK是否变1,如果变1,则主机已经发出
了第三个bit

15.再重复3-14,3遍,传完8bit数据.

16.主机发现SCLK=0,知道从机已经收完8位数据
17.主机将MCLK=1,准备下一轮通讯

18.从机发现MCLK=1,知道主机已经收起MCLK
19.从机将SCLK=1,准备下一轮通讯

附源代码：
sbit MCLK=P3^5;
sbit SCLK=P3^6;
sbit SDA=P3^7;
uchar bdata DATA;
sbit BIT0=DATA^0;
sbit BIT7=DATA^7;
// 发送一个数据
putbytespi(uchar ch)
{
    uchar i;
    uint c;
    
    if(!MCLK)return; //    
    MCLK=0;    //申请通讯
    DATA=ch;

    for(i=4;i!=0;i--)
    {
        while(SCLK); //检测从机响应
    
        SDA=BIT0;   //放一个bit到SDA
        MCLK=1;        
        DATA=DATA>>1; //准备下一个bit

        while(!SCLK); //检测从机响应
    
        SDA=BIT0;   //放一个bit到SDA
        MCLK=0;        
        DATA=DATA>>1; //准备下一个bit
    }
    while(SCLK); //检测从机收完
    MCLK=1;
    while(!SCLK);//等待从机准备好
    SDA=1;
}

//接收一个数据
//调用之前最好检测MCLK是否为0（对方是否申请数据通讯）再进入,否则里面是死等此信
号!
uchar getbytespi()
{
    uchar i;

    while(MCLK);
    SCLK=0;    //接受通讯请求

    for(i=4;i!=0;i--)
    {
        DATA=DATA>>1; //准备收下一个bit
        while(!MCLK); //检测主机放数据
        BIT7=SDA;//收一个bit
        SCLK=1;

        DATA=DATA>>1; //准备收下一个bit
        while(MCLK); //检测主机放数据
        BIT7=SDA;  //收一个bit
        SCLK=0;    
    }
    
    while(!MCLK); //检测主机发完
    SCLK=1;
    return(DATA);    
}